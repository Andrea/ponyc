#ifndef PASS_H
#define PASS_H

#include <platform.h>
#include "../ast/ast.h"
#include "../ast/frame.h"
#include "../ast/source.h"


PONY_EXTERN_C_BEGIN


/** Passes

The passes are split into 3 groups:

1. Module passes.

Run on every Pony source file when it is loaded, regardless of what pass any
other part of the AST is in.
Not run on ASTs built directly via the BUILD macros.

2. AST passes.

Run on all ASTs whether made from source files or generated by the compiler.

In general the sugar pass is run for each file after the module passes and the
other passes are then run for the whole program together. However, when a new
sub-AST is created, eg by sugar, we go back and apply passes to that sub-AST
until it has caught up with the rest of the AST. It is then treated as part of
the overall AST for the remaining passes.

Note that this process of going back and catching up passes for a sub-AST may
happen recursively. For example, during the expr pass a new anonymous class $1
may be created. We go back to catch that up and in it's sugar pass it creates
another new anonymous class $2. Now we catch up $2 to the main tree (expr pass)
and then finish catching up $1.

3. Generate passes.

Run on the whole program AST at once.


* Parse pass (module)

Turns a source file in an AST. Deliberately allows some illegal syntax to
enable better error reporting.

Expects Pony source file or string.

The data fields of all AST nodes, other than TK_PROGRAM, TK_PACKAGE and
TK_MODULE, are used as a set of flags for passing information to the syntax
pass. These flags are defined in parser.h.


* Syntax pass (module)

Checks for specific illegal syntax cases that the BNF allows. This allows for
better error reporting. If this pass succeeds then the AST is fully
syntactically correct.

Expects extra information in the data fields of most AST nodes, as described in
parse pass above.

Does not change the AST, other than to clear the data field flags.


* Sugar pass (AST)

Expands the AST to put in the code we've let the programmer miss out. This
includes default capabilities, method return values and else blocks. There are
also some code rewrites, such as assignment to update call and for loop to
while loop.

Not all sugar is perform here since some requires type check information which
is not yet available.

Substantially rewrites the AST.


* Scope pass (AST)

Creates entries in the relevant symbol tables for types, fields, methods,
locals, etc including initialising symbol definition status.

Also handles use commands, including loading other packages. Aliased used
commands are fully handled immediately. For use commands without aliases, the
used package is loaded but the resulting definitions are not merged into the
using package until the import pass.

Other than use commands, does not change the AST itself, only its symbol table
entries.


* Import pass (AST)

Imports symbols from packages "used" without an alias. This can't be done in
the scope pass due to complications from handling circular dependencies between
packages.

Does not change the AST itself, only module symbol table entries.


* Name resolution pass (AST)

TODO


* Flatten pass (AST)

TODO


* Traits pass (AST)

Adds methods inherited by entities from traits and interfaces, including
handling default bodies. Only chnages AST by adding methods to types and bodies
to previously bodiless methods.

Uses the data field of various AST nodes:
* For entities, as a marker to spot dependency loops.
* For methods, internally for storing a data block. At the end of pass points
  to the entity that provided the method body used, NULL if method has no body.
* For method bodies and error indicators, points to an entity providing an
  ambiguous default body.

Also performs minor anomalous tasks that have to be done before the type check
pass.


* Documentation generation pass (AST)

Auto-generates documentation, if the relevant command line flag is given,
otherwise does nothing.

Does not alter the AST at all.


* Expression type check pass (AST)

TODO


* Finaliser pass (AST)

Checks that any finalisers do not perfrom any restricted operations, such as
creating actors or sending messages.

Within finalisers uses the data field of the top body node and any TK_CALL
nodes as ast_send flags.

TODO: I think there may be a bug here. We appear to check the flags of many
nodes in a finaliser without necessarilly setting them first, ie we are
assuming the flags are clear at the start of the pass. However, this may not be
true depending on what previous passes have used the data field for.
Andy

*/
typedef enum pass_id
{
  PASS_PARSE,
  PASS_SYNTAX,
  PASS_SUGAR,
  PASS_SCOPE,
  PASS_IMPORT,
  PASS_NAME_RESOLUTION,
  PASS_FLATTEN,
  PASS_TRAITS,
  PASS_DOCS,
  PASS_EXPR,
  PASS_FINALISER,
  PASS_LLVM_IR,
  PASS_BITCODE,
  PASS_ASM,
  PASS_OBJ,
  PASS_ALL
} pass_id;

/** Pass options.
 */
typedef struct pass_opt_t
{
  pass_id limit;
  pass_id type_catchup_pass;
  bool release;
  bool library;
  bool ieee_math;
  bool no_restrict;
  bool print_stats;
  bool verify;
  bool strip_debug;
  bool print_filenames;
  bool docs;
  const char* output;

  char* triple;
  char* cpu;
  char* features;

  typecheck_t check;
} pass_opt_t;

/** Limit processing to the specified pass. All passes up to and including the
 * specified pass will occur.
 * Returns true on success, false on invalid pass name.
 */
bool limit_passes(pass_opt_t* opt, const char* pass);

/** Report the name of the specified pass.
 * The returned string is a literal and should not be freed.
 */
const char* pass_name(pass_id pass);

/** Report the pass after the specified one.
 */
pass_id pass_next(pass_id pass);

/** Report the pass before the specified one.
*/
pass_id pass_prev(pass_id pass);

/** Initialise pass options.
 */
void pass_opt_init(pass_opt_t* options);

/** Finish with pass options.
 */
void pass_opt_done(pass_opt_t* options);

/** Apply the per module passes to the given source.
 * Returns true on success, false on failure.
 * The given source is attached to the resulting AST on success and closed on
 * failure.
 */
bool module_passes(ast_t* package, pass_opt_t* options, source_t* source);

/** Apply the AST passes to the given whole program AST.
 * Returns true on success, false on failure.
 */
bool ast_passes_program(ast_t* program, pass_opt_t* options);

/** Catch up the given newly created type definition sub-AST to whichever pass
 * its containing package has reached.
 * Returns true on success, false on failure.
 *
 * Note that the insertion point considerations discussed for
 * ast_passes_subtree() also apply here. To allow for this we make the
 * following assumptions:
 * 1. Types are only ever added to the current module.
 * 2. Types are always added to the end of the current module, ie efter the
 *    generating node.
 * 3. Packages are always added to the end of the program.
 *
 * The current pass that types should be caught up to is stored in pass_opt_t.
 * Due to the above assumptions we catch up type sub-ASTs by applying all
 * passes BEFORE the stored value, not including it.
 *
 * A fail should be treated as an AST_FATAL, since some of the AST may not have
 * been through some passes and so may not be in a state that the current pass
 * expects.
 */
bool ast_passes_type(ast_t** astp, pass_opt_t* options);

/** Catch up the given sub-AST to the specified pass.
 * Returns true on success, false on failure.
 *
 * It is important to consider whether the given sub_AST will be processed
 * again during the current pass by the caller as this will affect the desired
 * last pass.
 *
 * For example:
 * Suppose that we apply the scope pass to some AST node A.
 * During the processing of A we create node B. We call this function to catch
 * B up to A and then carry on processing A.
 * Our original call to perform the scope pass then carries on to process the
 * rest of the AST accessible after A.
 * If B was inserted into the main AST at a point AFTER A then the current
 * scope application would eventually reach B and attempt to process it.
 * Therefore, when we caught up B we should only have brought it up to the pass
 * before scope (ie sugar).
 * However, if B was inserted into the main AST at a point BEFORE B then the
 * current scope application would not reach B. Therefore, when we caught up B
 * we should have brought it up to the scope pass.
 *
 * If the previous pass needs to be specified it is recommended to use
 * pass_prev() rather than hardcoding, as this will protect against any future
 * changes in the pass order.
 *
 * A fail should be treated as an AST_FATAL, since some of the AST may not have
 * been through some passes and so may not be in a state that the current pass
 * expects.
 */
bool ast_passes_subtree(ast_t** astp, pass_opt_t* options, pass_id last_pass);

/** Perform the code generation passes based on the given AST.
 * Returns true on success, false on failure.
 */
bool generate_passes(ast_t* program, pass_opt_t* options);


PONY_EXTERN_C_END

#endif
